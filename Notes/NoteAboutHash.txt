散列技术：
	通过某个函数f，使得
		存储位置 = f (关键字)
	这样，我们就可以通过查找关键字，不需要比较就可获得需要的记录的存储位置。
	这就是一种新的存储技术————散列技术。
	
散列技术是在记录的存储位置和它的关键字之间建立的一个确定的对应关系f，使得每个关键字key对应一个存储位置f（key）。

对应关系f称为，散列函数，或hash函数。
采用散列技术将记录存储在一块连续的存储空间中，这块连续的存储空间称为【散列表】或【哈希表】。


散列表查找步骤
	散列过程==> 两步
	（1）存储时，通过散列函数计算（要存储的）记录的散列地址，并按照散列地址存储该记录。
		不管甚么记录，都需要用同一个散列函数计算出地址再存储。
	（2）查找记录时，通过同样的散列函数计算记录的散列地址，然后访问该地址的记录。
	
散列技术既是一种存储方法，也是一种查找方法。
散列表中的【记录】之间不存在甚么逻辑关系，它只与关键字有关联。因此，散列主要是面向查找的存储结构。

散列技术最适合的求解问题：
	查找与给定值相等的记录。

散列表不适合的：
	一个key对应多个value；
	范围查找；
	
设计一个简单、均匀、存储利用率高的散列函数是散列技术中最关键的问题。

散列表的另一个问题：【冲突】
	关键字key1 != key2，但是f(key1) = f(key2)，这种现象称为冲突。
	并把key1和key2称为这个散列函数的【同义词】。
冲突可以尽量减少，但不能完全避免。

【构造散列函数】
	两个原则：计算简单、散列地址分布均匀

【几种常见的散列函数构造方法】
	【直接定址法】
		取关键字的某个线性函数值为散列地址：
		f(key) = a x key + b  (a、b为常数)
	
	【数字分析法】
	抽取：使用关键字的一部分来计算散列存储位置的方法
	
	【平方取中法】
	【折叠法】
	【除留余数法】
	【随机数法】
构造散列函数的参考因素：
	计算散列地址所需的时间；
	关键字的长度；
	散列表的大小；
	关键字的分布情况；
	记录查找的频率。
	
【处理散列冲突的方法】
	【开放定址法】
		一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到。
		【线性探测法】：冲突则 +1 mod 长度 如果还冲突 则变成 + 2 、+ 3直到 +长度 或 找到空的位置
	【堆积】：本来不是同义词却要争夺一个地址的情况。
		【二次探测法】：冲突则在key + 1^2 、（-1^2）... 1^2 、（-q^2）  q <= m/2 （m为散列表长度）这样可以实现双向查找
		【随机探测法】：冲突时 + 的值d采用随机函数（伪随机）计算得到。

	【再散列函数法】
		准备多个散列函数，冲突时用第二、第三个函数计算地址->增加了计算成本
		
	【链地址法】
		将所有关键字为同义词的记录存储在一个单链表中，称这种表为同义词子表。
		在散列表中只存储所有同义词子表的头指针。
		（查找时需要遍历单链表，为什么，数组 可以 index * 元素字节数  来计算地址；链表如何计算地址？全部遍历？）
		（那我用key去找value的时候，如何确定这个key对应的是链表中的哪个value呢？）
	
	【公共溢出区法】
		为所有冲突的关键字建立了一个公共的溢出区来存放。（溢出区貌似是顺序存放的，一个冲突则放0的位置，然后接着往下）
		对给定key通过散列函数计算出散列地址后，先与基本表的相应位置进行对比，如果相等则查找成功；
		如果不相等，则到溢出表去进行【顺序】查找。
		如果冲突的数据很少的情况下，查找性能来说还是非常高的。

【散列表查找实现】
P366
	